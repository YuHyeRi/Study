# Java -02



### Q. 자바의 특징은?

**객체 지향적** 프로그래밍 언어, JVM 덕분에 어느 플랫폼에서나 동일한 형태로 실행할 수 있다. 따라서 자바로 개발된 프로그램은 CPU나 운영체제의 종류에 관계없이 JVM을 설치할 수 있는 시스템 어디서나 실행할 수 있다. 동적로딩을 지원하여 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다.



### Q. JDK란?

자바 환경에서 돌아가는 프로그램을 개발하는 데 필요한 tool들을 모아놓은 소프트웨어 패키지로 JRE, java바이트코드 컴파일러, 디버거 등을 포함하는 개발 도구들로 이루어져있다.



### Q. Array와 List의 차이는?

***🟣 Array***

- 선언시 배열 크기 지정이 필요하다. (ex. String list - new String[7]; )
- 객체를 넣을 때 index 번호르르 정의해야 한다.
- 다차원 저장이 가능하다.
- 선언시 메모리가 할당된다.
- 기본 데이터 타입(Primitive Type), 오브젝트(Object) 할당이 가능하다.
- 접근이 빠르다 (→ index 번호로 random access를 하기 때문에)

***🟣 List***

- 사이즈 지정을 하지 않아도 동적으로 변화한다.
- 그냥 넣어도 된다. (ex. list.add(’book’); )
- 다차원 저장이 불가능하다.
- 오브젝트(Object)만 할당 가능하다.
- 추가 및 삭제가 빠르다 (→ pointer로 Sequential access를 하기 때문에)



### Q. String, StringBuffer, StringBuilder의 차이는?

- **String**은 값을 변화시킬 때, Heap에 ***새로운 메모리를 사용하고 참조되는 메모리 주소만 바꿔줌***
- **StringBuffer, StringBuilder**는 Stack에 값을 저장하므로 값이 변화할 때 값을 바꿔 씀
    
    → StringBuffer는 Thread-safe로 멀티스레드 환경에서 안전하다.
    
    → StringBuilder는 StringBuffer보다 빠르다.
    


### Q. 기본 접근제어자(default)와 protect 접근 제어자의 차이는?

클래스에서 접근제어자를 지정하지 않고 메소드나 변수를 선언했을 때에는 접근제어자가 기본적으로 default 형이 된다. ***default*** 멤버는 같은 패키지 안의 다른 패키지 클래스에서 볼 수 있지만, 해당 멤버 패키지 이외의 클래스에서는 볼 수 없다.

protected는 default와 동일하지만, ***protected*** 클래스를 상속한 클래스는 패키지 밖에서도 볼 수 있다는 것이 차이점이다.



### Q. 해쉬맵과 해쉬테이블의 차이는?

🟣 ***HashMap***

- 메소드 동기화를 지원하지 않는다.
- Thread-safe가 아니다.
- Iterator를 사용한다.
- 하나의 Null key와 여러개의 Null value를 허용한다.
- 성능이 비교적 빠르다.

🟣 ***HashTable***

- 메소드 동기화를 지원한다.
- Thread-safe 이다.
- Enumerator를 사용한다.
- Null을 허용하지 않는다.
- 성능이 비교적 느리다.

(*정렬 순서를 유지하고 싶을 경우에는 키값이 트리구조 기반인 TreeMap / 노드가 포인터값을 포함하는 LikedHashMap도 사용을 고려할 수 있다. 다만 이 경우에는 get() 으로 호출시 시간복잡도가 O(logn), O(n)으로 호출 속도가 저하되는 것이 단점이다. 해쉬맵은 키를 해쉬값으로 호출함으로 O(1)이다.)



### Q. 해쉬셋과 트리셋의 차이는?

***🟣 HashSet***

- 넣은 순서대로 저장 순서를 유지하지 않는다.
- null 객체를 저장할 수 있다.
- 검색 성능이 비교적 빠르다.
- 동일 타입 오브젝트 저장 허용한다.
- 비교 오퍼레이션 시, equals 메소드 사용한다.

🟣 ***TreeSet***

- 넣은 순서대로 저장 순서를 유지하지 않는다. (→ 오름차순 정렬)
- null 객체를 저장할 수 없다.
- 검색 성능이 비교적 느리다.
- 동일한 타입의 오브젝트 저장 불가하다. (ClassCastException 발생)
- 비교 오퍼레이션시 comparedTo 메소드 사용한다.

***🟡 결론*** 

중복, 순서 관계 없는 데이터 집합이 필요하다면 → ***HashSet***

정렬이 필요한 데이터 집합이 필요하다면 →  ***TreeSet***

순서를 보장하는 데이터 집합이 필요하다면 → ***HashLinkedSet***



### Q. 자바 컬렉션이란?

***🟣 정의***

: 객체를 저장하도록 설계된 프레임워크이다. 검색, 정렬(소트), 조작, 삽입, 삭제 등의 오퍼레이션을 수행할 수 있는 객체 집합을 컬렉션이라고 한다. 컬렉션은 자바 인터페이스로 구현되는데, 자료구조 중 list와 set는 컬렉션 인터페이스를 상속하여 정의하고, map은 구조상의 차이로 별도로 정의된다.

***🟣 정렬***

Ordered : 컬렉션에 추가된 순서대로 저장되는 컬렉션

Sorted : 객체 속성에 따라 내부적으로 정렬함

***🟣 분류***

 ***1. List -리스트***

- 삽입 순서가 의미를 가진다.
- 중복을 허용한다.
- ITERATION가 빠르다
1. ***Set -세트***
- 고유한 값을 가지는 자료구조로 중복을 허용하지 않는다.
- 인덱스를 사용하지 않으므로 저장순서가 보장되지 않는다. (→ 검색시 iterator 메소드로 데이터를 불러와야 한다.)
1. ***Map -맵***
- 분별자(Key)가 고유한 값을 가지는 자료구조로, Key는 중복되어서는 안 된다.



### Q. 예외(Exception)란?

***🟣 정의***

: 예외란 실행 중에 발생할 수 있는 개발자가 구현한 로직에서 발생하는 문제를 말한다. (* 로직과 관계없는 문제는 오류로 정의한다.) 런타임 중에 문제가 발생하면 메소드는 예외를 던져 문제 발생을 알린다. 예외처리가 안되면 task가 완료되기 전에 실행은 멈춰버리게 되지만, 예외 처리를 하면 플로우는 계속될 수 있다.

***🟣 예외 처리를 해서 얻을 수 있는 이점***

1. 실행을 멈추지 않고 진행하게 할 수 있다.
2. 개발자가 문제를 확인할 수 있다.

***🟣 종류***

1. ***체크 예외 (Check Exception)***
- 컴파일 단계에서 확인되는 예외들이다.
- 반드시 명시적으로 처리해야 한다.
- 로직상 예외 발생 가능성이 있는 상황들을 표현한다. 대표적으로 IOException, SQLException, ClassNotFoundException 이 있다.
- 주로 JVM 외부와 통신 시에 발생하는 예외들이다.
1. ***언체크 예외(Uncheck Exception)***
- 실행 단계에서 확인 되는 예외들이다.
- 명시적인 처리를 강제하지 않는다.
- RuntimeException 클래스의 하위 클래스들이 모두 여기에 속한다. 여기에 속하지 않으면 체크 예외이다.



### Q. 예외 처리 방법은?

1. ***[복구형] Try / Catch 블록***

→ 예외 발생 가능성 있는 코드를 try 문으로 감싸고, 발생시에 처리는 catch에서 받아서 한다. 즉, try-catch 블록을 사용하면 ***해당 메소드에서 예외를 처리하게 된다.***

1. ***[회피형] throw 키워드 선언***

→ 메소드 끝단에 throws Exception을 선언하여 처리한다. 예외 발생 시, ***메소드를 호출한 코드로 예외를 되돌려 보내서 처리***하게 하는 방식이다.

1. ***[전환형] catch에서 다른 예외를 던지는 것***

→ 호출 측에서 ***에러의 타입을 명확하게 인지할 수 있도록 예외를 던져주는*** 것이다.



### Q. 파이널(Final) 키워드에 대하여

1. ***변수*** : 변수가 일단 fianl로 선언되면 변수의 값은 덮어 씌워질 수 없다.
2. ***메소드*** : final 메소드는 오버라이드 될 수 없다.
3. ***클래스*** : 클래스가 final로 선언되면 상속될 수 없다.
4. ***생성자*** : 생성자는 final이 될 수 없다.



### Q. 자바의 기본형 데이터 타입 / 참조형 데이터 타입

***🟣 기본형 데이터 타입***

boolean, char, byte, short, int, long, float, double

(*32비트 환경에서 char형은 2바이트, byte형은 1바이트, short형은 2바이트, int형은 4바이트, long형은 8바이트, float은 4바이트, 더블은 8바이트)

🟣 ***참조형 데이터 타입*** → 객체의 주소를 저장하고 참조하는 타입

class, array(배열), enum(열거), interface



### Q. OOP란?

Object-Oriented Programming의 약자로 ‘ ***객체 지향 프로그래밍 언어*** ‘ 를 뜻하며 부품에 해당하는 객체들을 먼저 만들고 이것들을 하나씩 조립, 연결하여 전체 프로그램을 완성하는 기법



### Q. 캡슐화란?

캡슐화는 객체에 대한 관련 데이터들과 행위를 하나로 묶어 ***외부에 노출되지 않도록*** 은닉하는 것. 캡슐화를 하면 객체의 사용자로부터 정보 은폐가 가능하며 객체를 포함한 정보의 손상과 오용을 막을 수 있다. 또한 처리된 결과만 사용하므로 객체의 이식성이 좋다. 



### Q. 다형성이란?

다형성이란 동일한 부모 클래스 타입을 상속받은 후손 클래스 타입들을 부모타입으로 처리하는 기술이다. 이 다형성을 지원하기 위해서는 **동적 바인딩**이 필수다. 동적 바인딩이란 부모타입으로 참조되는 후손객체의 오버라이딩 메소드에 적용되며, 컴파일 시에는 부모의 메소드를 정적 바인딩 해두었다가 프로그램이 실행될 때 참조하는 후손의 오버라이딩 메소드로 연결을 바꾸어 실행하는 것이다.



### Q. 상속이란?

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

- 장점 : 코드의 재사용성을 높이고 중복을 제거하여 생산성 향상과 보다 편한 유지보수가 가능
- 단점 : 굳이 말하자면, 상속 받은 부모클래스 변형 시, 자식클래스도 동일하게 변형되어 개별적으로 수정이 불가능



### Q. class, instance ?

- ***class*** : 실제로 존재하는 객체들의 공통점을 추상화하는 것
- ***instance*** : 추상화 된 개념을 실재하도록 하는 것. class를 instance화 한 것을 인스턴스(객체).



### Q. thread와 thread를 구현하기 위한 인터페이스, 클래스

thread는 프로세스 내에서 실행되는 세부 작업의 단위이다.

thread를 구현하기 위한 인터페이스는 Runnable이며, 클래스는 Thread.



### Q. static

변수에 static을 적용하면 같은 클래스 타입의 객체들이 공유할 수 있는 클래스 변수가 된다. static 메소드는 객체에 의존적이지 않은 작업을 수행할 수 있다. 클래스명을 통한 메소드 호출이 가능하다. 오버라이딩도 되지 않으며, 상속받은 클래스에서 사용할 수 없다.

(+ 클래스가 초기화될 때 수정되고 main()메소드보다 먼저 수행되는 static 초기화 블록으로도 사용가능)



### Q. 제네릭

클래스 내부에서 사용할 데이터 타입을 인스턴스가 생성될 때 확정하도록 하는 것.



### Q. 배열과 ArrayList의 차이는?

- ***배열*** : 같은 타입의 데이터를 연속된 공간에 나열시키고 ***각 데이터에 인덱스를 부여***해놓은 자료 구조
- ***ArrayList*** : 배열의 구조를 가지고 있으나, 기본배열과는 다르게 기존의 인덱스를 부여해놓고 그 인덱스 안의 값을 저장하는 것이 아니라, 입력시킨 값만큼의 인덱스를 생성하여 배열이 되는 구조



### Q. Stack, ArrayList, List 차이는?

- ***Stack*** : List 인터페이스를 구현한 Vector 클래스를 상속받아 구현한 클래스이다. Stack은 LIFO(선입후출) 알고리즘이 적용된 자료구조이다.
- ***List*** : 자바 컬렉션 프레임워크에서 제공되는 인터페이스 중 하나로 데이터의 순서를 지정하는 인덱스와 데이터로 구성되는 자료구조이다.
- ***ArrayList*** : List 인터페이스를 인스턴스화 할 수 있도록 구현한 클래스 중 하나이다.



### **Q. 접근제어자의 종류와 특성은?**

1. **private** : 같은 클래스 내에서만 접근 가능
2. **default** : 같은 패키지 내에서만 접근 가능
3. **protected** : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
4. **public** : 접근 제한 없음



### Q. hashCode() 값이 모두 같다면?

자바의 hashCode()는 heap에 있는 객체의 메모리 주소를 바탕으로 생성된 값인 hashCode를 반환. 이 hashCode 값이 모두 같으면 모든 객체의 레퍼런스가 같거나, 같은 객체인 것으로 간주되어 클래스 간의 구분이 불가능하다.



### Q. HashTable과 HashMap의 차이점은?

- **hashTable** : 동기화 된 메소드로 구성되어 있기 때문에 멀티스레드가 동시에 이 메소드를 실행할 수 없고, 하나의 스레드가 실행은 완료해야만 다른 스레드가 실행 가능
- **hashMap** : Thread Safe 기능이 제외된 메소드를 제공



### Q. 객체의 직렬화, 직렬화 대상이 되기 위해 구현해야 할 인터페이스

자바 I/O(입출력)에서 객체(Object) 입출력은 기본적으로 **byte 단위의 처리만** 지원하고 있기 때문에 객체를 Stream 처리하기 위해 byte 단위로 변환해야 한다. 이렇게 byte 단위로 변환하는 것을 ‘ **객체 직렬화** ‘ 라고 한다. 클래스가 직렬화 대상이 되도록 하려면 **serializable** 인터페이스를 구현하여야 한다.



### Q. 자바로 자판기를 설계한다면

처음 자판기의 버튼 번호와 그에 해당하는 가격을 각각 객체로 받아 List & Map으로 만들고 들어온 금액을 별도의 변수에 담아 버튼 click 이벤트가 발생했을 때, 눌려진 버튼의 정보를 가져와 (switch문, if-else 조건문) 해당하는 가격과 입금한 금액의 차이를 비교한 후, 0이면 주문을 수행하고 0보다 크면 주문 수행 후 거스름돈 표시, 0보다 작으면 ‘금액이 적습니다’ 라는 에러 문구를 자판기에 띄워주면 된다.



### Q. JavaScript에서 replace에 들어가는 인자 값?

replace(”**str1**”, “**str2**”); 

- **str1** → 바꾸고자 하는 원래 문자열
- **str2** → 바꿀 문자열



### Q. Garbage Collection

- GC란 프로그램이 사용하지 않는 메모리영역을 자동으로 수거, 관리해주는 기술이다. 이를 통해 사용자는 Java로 프로그램을 만들 때, 메모레 관리에 대해 별도 고민이 필요하지 않다.
- Java는 **JVM에 의해 리소스가 관리 되는데** 그 중, 동적메모리인 **Heap**을 크게 세 영역으로 나누어 데이터를 저장한다. (young영역, old영역, perm영역) 이 중 perm 영역은 실행할 소스코드를 저장하기 때문에 메모리를 함부로 다룰 수 없다. 따라서 앞의 두 영역의 메모리를 관리하는데 객체의 생성과 삭제 시기를 기준으로 즉석 객체면 young 영역, 즉석객체가 아니면 old 영역으로 나눈다. GC는 여기서 사용되지 않는 객체가 가지는 메모리를 찾아 비움으로써 시스템 메모리를 관리한다.



### Q. thread와 프로세스의 차이

- ***프로세스*** : 운영체제로부터 할당받는 프로그램의 최소단위, 하나 이상의 thread를 가짐
- ***thread*** : 프로세스 안의 여러 실행의 흐름
- 차이점은

→ ***프로세스*** : Code, Data, Heap, Stack 영역을 공유하지 ❌

→ ***thread*** : Stack 영역을 제외한 메모리영역을 공유 ⭕, 따라서 thread는 프로세스에 비해 자원소모가 줄고 응답시간이 단축된다. 그러나 공유하는 메모리영역에 대해 오류가 생길 수 있으니 주의를 요하고 디버깅이 어렵고 단일 프로세스에서는 효과를 기대하기 어렵다.



### Q. DAO란?

DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 Object



### Q. finalize()

자바 가상머신이 메모리 누수를 방지하기 위해 실행하는 **GC**이 수행될 때 더이상 사용하지 않는 자원에 대한 **정리 작업을 진행하기 위해 호출되는 종료 메소드**



### Q. 추상클래스

하나 이상의 ‘ ***추상메소드*** ‘를 포함하는 클래스로 클래스명 앞에 ‘ ***abstract*** ‘ 라는 키워드가 붙는다. 객체화할 수 없다. 클래스 자체로는 클래스의 역할을 하지 못하고 새로운 클래스를 작성하는 데 있어 부모 클래스로서 역할을 한다.



### Q. 인터페이스

상속하는 클래스들은 인터페이스의 메소드들을 반드시 구현해야 하기 때문에 동일한 메소드를 만들도록 규악으로 작용할 수 있다.



### Q. main 메서드가 static 인 이유는?

정적 메소드는 객체를 생성하지 않아도 자동으로 실행되는데, ***메인 메소드는 자동으로 실행되어 작업을 수행해야 하기 때문***이다.



### Q. 리플렉션

특정 클래스의 변수, 메소드의 정보를 구해오는 것이다.



### Q. 변수 명명법이 중요한 이유는?

협업 시 가독성을 좋도록 하기 위함



👉 노션 : https://www.notion.so/Java-02-e094ede4b21a430fad9384db3517806d

👉 출처 : [https://gem1n1.tistory.com/46?category=784306](https://gem1n1.tistory.com/46?category=784306)

[https://jishushu.tistory.com/6](https://jishushu.tistory.com/6)
